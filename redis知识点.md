<center>redis</center>
##### redis是什么？

 * C语言编写的开源遵从BSD协议高性能KV(not only sql)的内存数据库，可以用作数据缓存，消息中间件，消息队列，消息通知，活动排行榜等

##### redis的特点

 * 1.作为内存数据库，性能优秀，数据在内存中读写非常快，支持10QPS并发  QPS(每秒查询率)
 * 2.单进程单线程，是线程安全的，采用IO多路复用机制
 * 3.丰富的数据类型 string ，hash， list ，set， sorted set
 * 4.支持数据持久化，可以将内存中的数据保存到数据库中，重启时加载 RDB AOF
 * 5.支持主从复制，高可用， 哨兵模式监控主从，以及在主服务宕机之后，选出新的主服务机
 * 6.可以用作分布式锁，
 * 7.可以作为消息中间件，支持订阅

##### redis 的五种数据类型

* ![image-20200301154330987](C:\Users\HYY\AppData\Roaming\Typora\typora-user-images\image-20200301154330987.png)

* redis内部使用redis object来表示所有的key和value，type表示一个value对象具体是何种类型，encoding是不同对象在redis内部的存储方式，比如 type=string表示value存储的是一个普通字符串，那么encoding可以是raw或者int

* 1.string 是redis的基本数据类型， **一个key对应一个value**，value不仅是string，也可以是数字，string是二进制安全的，string类型可以包含任何数据包括jpg图片或者序列化对象。

* 2. hash 是一个键值集合 。**redis的hash是一个string的key和value的映射表**  

  * hash特别适合存储对象。 常用命令 hget，hset，hgetall等

* 3. list 列表是简单的字符串列表，按照插入顺序排序，可以头插或者尾插，常用lpush，rpush，lpop，rpop， lrange(获取列表片段)

  * 数据结构 redis的list 就是链表，可以用作消息队列，redis提供了pop和push操作，还提供了操作某一段的api，可以直接查询或删除某一段的元素。
  * lrange命令， 做基于redis的分页功能
  * 实现方式  **双链表，支持反向查找和遍历**，更方便，不过带来了**额外的内存开销**。

* 4. set  集合   通过**hash table实现，set中元素无序且无重复**。常用命令 sdd， spop，smembers， sunion

  * 应用场景： 自动去重的list，而且可以判断某个成员是否在同一个set中。

* 5. sorted set 有序集合， 通过用户提供的sorce来为元素进行排序。 是一个有序且无重复元素的集合列表

  * 实现方式  **Redis sorted set的内部使用HashMap和skipList(跳跃表)来保证数据的存储和有序**，**HashMap**里放的是**成员到score的映射**，而**跳跃表里放的是所有的成员**，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且实现比较简单。
  * skiplist跳跃表 指的就是 除了最下面的一层链表之外，它会产生若干层稀疏的链表，这些稀疏链表故意跳过了一些节点(而且层数越高层的链表跳过的节点越多)，这就使得我们在查找数据的时候能够先在高层的链表中快速查找，然后逐层降低，最终来到第一层链表来精确地确定数据位置![image-20200301161442888](C:\Users\HYY\AppData\Roaming\Typora\typora-user-images\image-20200301161442888.png)

##### 缓存雪崩

 * 概念：大面积缓存同一时间失效，使得大量请求直接落到数据库上，而对数据库CPU和内存造成巨大压力，严重时造成数据库宕机。造成连锁反应，最终系统崩溃。
* 解决方案： 在设置缓存时给过期时间加上一个随机值。
  * 如果是集群部署，也可以把热点数据分布在不同的redis库中
  * 极端方法 热点数据永不过期。

##### 缓存穿透

 * 概念： 缓存和数据库都没有的数据，而用户不断发起请求。 例子： 数据库id都是从1开始自增的，如果发起id=-1的数据请求或者id特别大数据库没有的请求，这样不断的攻击导致数据库压力很大，严重会击垮数据库。
 *  解决方案： 在接口层增加检验，参数做检验，不合法的校验直接返回 避免去数据库查找。

##### 缓存击穿：

 * 概念： 一个非常热点的数据扛着大量的请求，大并发集中对这一点进行访问，当这个key失效的瞬间，就会让大并发请求直接落到数据库上，就在该点击穿了缓存
 * 解决办法： 设置热点数据永不过期

##### 缓存预热

* 在系统上线后，将相关的缓存数据直接加载到缓存系统，这个就可以避免在用户请求的时候，先查数据库再查缓存。

##### 缓存更新：

* redis自带的缓存失效策略
  * 1 cache aside
  * 2 Read through  在查询操作中更新缓存， 当缓存失效的时候(过期或LRU换出)，缓存服务自己加载
  * 3 write through  在更新数据时，当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中缓存，则更新缓存。 再由cache自己更新数据库
  * 4. write behind caching pattern

##### 缓存降级

* 降级的目的 保证核心服务可用，防止redis服务故障，导致数据库跟着一起发生雪崩问题。

##### Redis为什么这么快

* redis 官方提供的数据可以到达每秒10w+的QPS(每秒查询次数)

##### Redis的“单线程模型”

* redis确实是单进程单线程的模型，因为redis是完全基于内存的操作，CPU不是redis的瓶颈， redis的瓶颈最有可能是机器内存的大小或者网络带宽。
* 单线程容易实现，而且CPU不会成为瓶颈，(毕竟多线程会有很多麻烦)

##### redis是单线程为什么还能这么快

* **所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。**

* redis完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于hash map 优势就是查找和操作的时间复杂度是O(1)
* 数据结构简单，对数据操作简单
* 采用单线程**避免了不必要的上下文切换和竞争条件**，**不存在多线程导致的CPU切换**，不用考虑各种锁的问题，不存在加锁释放锁操作，没有死锁操作问题导致的性能消耗问题
* 使用多路复用IO模型，非阻塞IO
  * **非阻塞I/O** ，**Redis采用epoll做为I/O多路复用技术的实现** ，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间

##### I/O多路复用：

* I/O 多路复用模型是**利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力**，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是**程序就会轮询一遍所有的流**（epoll是只轮询**那些真正发出了事件的流**），依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
* 多路”指的是多个网络连接
* “复用”指的是复用同一个线程
* 采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

##### redis淘汰策略

* volatile-lru 从已设置过期时间的kv集里优先对最近最少使用的数据淘汰
* volitile-ttl 从已设置过期时间的kv集中优先对剩余时间短的数据淘汰
* volitile-random  从已设置过期时间的kv中随机淘汰
* allkeys-lru 从全部kv集中优先对最近最少使用的数据淘汰
* allkeys-random 从全部kv集中随机淘汰
* noeviction 不淘汰策略，若超过最大内存，返回错误信息
* volaitle-lfu 最不经常使用
* allkeys-lfu 
* 默认noeviction 

#####  持久化

* RDB  快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。
* AOF 把所有的对redis 的服务器进行修改的命令都保存到一个文件里，命令的集合。
* redis 默认是RDB

##### 主从复制

























