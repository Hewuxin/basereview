<center>操作系统</center>
##### 进程与线程区别

* 1进程是资源分配和调度的单位，线程是CPU分配和调度的单位。

* 2线程依赖于进程存在，一个进程可以有多个线程

* 3进程独享地址空间，线程除了必不可少的资源如(寄存器和栈等)基本不占用系统资源

* 4线程之间通信更加方便因为共享进程的全局变量等数据，而进程之间需要通过进程通信的方式通信

* 5进程开销远大于线程开销，进程切换时需要保存当前进程的CPU运行环境以及新进程的CPU环境设置，而线程只需要保存和设置少量寄存器的内容。

* 6多线程一旦有一个线程崩溃程序就会崩溃，而多进程之间互不影响。

* ###### 进程让操作系统的并发成为可能，而线程让进程的内部并发成为可能。

##### 进程间通信方式有哪些

* 1.管道 半双工，数据只能单向流动，  只能用于父子进程或者兄弟进程(具有血缘关系的进程)
* 2.命名管道
* 3.消息队列
* 4.信号 signal
* 5.共享内存
* 6.信号量  初始化操作  p操作 v操作 p操作信号量-1 <0进入阻塞状态  v操作信号量+1 小于等于0从队列唤醒一个等待的进程进入就绪状态

##### 僵尸进程

* 一个**子进程结束后，它的父进程并没有等待**它（调用wait或销毁waitpid),那么这个子进程将成为一个僵尸进程。   
* 特点： 已经死亡，没有被销毁
* 危害 占用进程号pid，而系统所能使用的pid是有限的，占用内存。
* 不会产生僵尸进程的情况：
  * 该进程的父进程先结束。   父进程结束后由init进程接管，成为该进程的父进程，并且调用wait等待其结束。
  * 父进程调用wait或waitpid等待子进程结束(需要每隔一段时间查询子进程是否结束)
  * 也可以用signal(SIGCLD,SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。

##### 孤儿进程

​	一个**父进程已经结束了，但是它的子进程还在运行，那么这些进程将成为孤儿进程**。孤儿进程会被Init(进程ID为1)接管，当这些孤儿进程结束时由Init完成状态收集工作。

##### 多线程并发

* 将复杂的执行逻辑与调度机制的细节，交替执行的操作，异步I/O以及资源等待等问题分离开来。
* 提高资源利用率，多处理器系统的出现，使得同一个程序的多个线程可以被同时调度到多个CPU上运行。    多线程程序可以通过提高处理器资源的利用率来提升系统的吞吐率。
* 多线程的性能不一定优于单线程，**对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源**，如果采用多线程，线程切换导致的开销反而会让性能下降。   对于**IO密集型任务，肯定是需要使用多线程的**。  
* 使用 queue进行线程通信。当线程之间如果需要共享资源或数据的时候，可能变得非常复杂。python的threading模块提供了很多同步原语。

##### 线程同步方式

* 线程同步就是协调同步，按预定的先后次序进行运行。  同步是 指**协同，协助，互相配合**。
* 线程同步是指**多线程通过特定的设置(如互斥量，事件对象，临界区) 来控制线程之间的执行顺序，**也可以说是在线程之间通过同**步建立起执行顺序的关系**，如果没有同步，那线程之间是各自运行各自的。
* 线程互斥是指对于共享的进程系统资源，在各个单线程访问时的**排他性** 。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须**等待**，直到占用资源者释放该资源。  线程互斥可以看成是一种特殊的线程同步
  * **互斥量Mutex**：采用互斥对象机制，只有**拥有互斥对象的线程**才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问，当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源。（RLOCK 和LOCK）
  * **信号量Semaphare** :  它运行同一时刻多个线程访问统一资源，但是需要控制同一时刻访问此资源的最大线程数量。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。
  * **事件对象Event** 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。事件是内核对象，事件分为手动置位事件和自动置位事件。 事件Event内部它包含一个使用计数（所有内核对象都有), 一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。

##### 线程状态切换

​	![image-20200228144003125](C:\Users\HYY\AppData\Roaming\Typora\typora-user-images\image-20200228144003125.png)







##### 分页和分段有什么区别

* 在段式存储管理中， **将程序的地址空间划分为若干段，如代码段，数据段，堆栈段**，这样每个进程有**一个二维地址空间**，相互独立，互不干扰。

  * 段式管理的优点是： **没有内碎片(因为段大小可变，改变段大小来消除内碎片)**。但段换入换出时，**会产生外碎片**(比如4k的段换5k的段，会产生1k的外碎片)

* 页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将**程序的逻辑地址划分为固定大小的页，而物理内存划分为同样大小的帧**，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点时：**没有外碎片(因为页的大小固定),**  **但会产生内碎片** （**一个页可能填不满**）

* 两者的区别：

  * 目的不同： 分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；

  * 大小不同: 页的大小固定由系统决定，而段的长度却不固定，由其所完成的功能决定。

  * 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间，

  * 信息共享： 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享收到限制；

  * 内存碎片：页式存储管理的优点是没有外碎片(因为页的大小固定)，但会产生内碎片(一个页可能填充不满)；而段式管理的优点是没有内碎片(因为段大小可变，改变段大小来消除内碎片)。但段换入换出时，会产生外碎片。

 ##### 页面置换算法

* 功能 当缺页中断发生时，内存决定哪一个物理页面被换出
* OPT(最优置换算法)：根据将来什么时候会访问来设置  不可能实现的算法 作为评估标准 

  * 无法实现的原因： 操作系统无从知道每一个页面要等待多久才会再次被访问
* FIFO(先进先出算法):  选择在内存中驻留最久的页面置换

  * 缺点 换出的页面可能是经常要访问的页面  有抖动现象
* LRU(最近最久未使用)  当发生缺页中断是选择最近未使用的页面置换

  * 原理：  程序的局部性原理， 在最近一小段时间，如果某些页面被频繁访问，那么在接下来的一段时间，它们还会被访问。
  * 缺点 开销大 需要记录 访问事件  堆栈 置换栈
* 时钟页面置换算法clock 
  * 需要用到页表的访问位，当前页面被装入内存时，把该位初始化为0， 如果该页被读写则把该页置为1
  * 把各个页面组织成一个环形链表，

* 二次机会法   时钟的基础上多加一位 
* LFU(最不经常使用)  
  * 当一个缺页中断发生时，选择访问次数最少的那个页面进行置换

##### 进程调度算法

* 1.FCFS(先来先服务)   缺点：平均等待时间较长
* SJF(短进程)   缺点： 如果有源源不断的短进程到来会造成长进程长时间饥饿 
* SRTN(最短剩余时间优先)    缺点可能导致饥饿
* HRRN(最高响应比优先)   
  * 响应比 = (等待时间+处理时间出)/处理时间  很好的平衡了长短进程
  * 缺点 非抢占式，吞吐量高，开销可能较大，提供了好的响应时间，无饥饿产生
* RR(轮询)  
  * 将所有就绪进程按FCFS的原则排成一个列，用完时间片的进程排到队列最后。
  * 抢占式(时间片用完)，开销小，无饥饿问题，为短进程提供了好的响应时间
  * 缺点  若时间片过小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证
* 优先级调度
  * 调度时选择优先级最高的作业进程
  * 优点  区分紧急程度 适用于实时操作系统，可灵活地调整对各进程的偏好程度
  * 缺点 若源源不断地有高优先级进程到来，会造成饥饿

* 多级反馈队列调度算法
  * 设置多级就绪队列，各级队列优先级从高到底，时间片从小到大
  * 优点 ： 
    * 相对公平，每个新到达进程都可以很快得到响应(RR)
    * 短进程只用比较少地时间就可以完成(SPF)
    * 不必实现估算进程地运行时间(避免用户作假)SPF缺点
    * 可灵活调整对各类进程地偏好程度，比如CPU密集型进程，I/O密集型进程  可以将被阻塞地进程放到原队列，这样I/O型进程就可以保持较高优先级。
  * 缺点会导致 饥饿

##### 死锁

* 概念： 各进程都互相等待对方手里的资源，导致各进程都阻塞，无法向前推进。
* 死锁产生的必要条件：
  * 1.互斥条件： 对必须**互斥使用的资源的争抢**才会导致死锁  如(打印机)
  * 2.不可剥夺条件: 进程**持有的资源在未使用完毕前，不能由其他进程强行夺走**，只能自己释放。
  * 3.请求和保持条件： 进程已经**保持了至少一个资源，但又提出了新的资源请**求，而该资源又被其他资源占有，此时请求进程被阻塞但又对自己占有的资源不释放。
  * 4.循环等待条件： 存在一种**进程资源的循环等待链**，链中的每一个进程已获得的资源同时又被另一个进程所请求   哲学家进餐问题
* 发生死锁一定会循环等待，循环等待不一定是死锁
* 什么时候发生死锁：  对不可剥夺资源的不合理分配，可能产生死锁
  * 1 对系统资源的竞争  各进程对不可剥夺资源的竞争可能导致死锁(打印机)
  * 2 进程推进不合理，请求和释放资源的顺序不当。
  * 3 信号量使用不当

##### 死锁的处理策略

 * 1 预防死锁 破环死锁产生的必要条件：

    *  破环互斥条件 将临界资源改造成可共享使用的资源(打印机添加一个接收序列，进程提交任务后就可以继续向下执行)
       	*  缺点 很多临界资源并不能改造
    *  破坏不可剥夺条件   
       	*  让权等待  如果进程运行所需资源不满足，立即释放手中的所有资源
          	*  所需的资源被占用时，由操作系统协助剥夺(优先级)
        *  缺点： 实现复杂， 而且被剥夺资源的进程可能已经完成大部分工作，剥夺后就会失效
           	*  反复申请和释放导致系统开销大，可能导致饥饿(一直有高优先级进程请求资源)

   * 破环请求和保持条件：运行之前分配好所需资源，之后一直保持 
     * 缺点：资源浪费
   * 破环循环等待条件：给资源编号，从小到大的顺序申请资源
     * 缺点不方便增加新设备，会导致资源浪费， 用户编程难度增加

*  2.避免死锁：

   *  有某种算法防止系统进入不安全状态，从而避免死锁(银行家算法)
   *  银行家算法步骤：
      *  1.检查此次申请是否超过了之前声明的最大需求数
      *  检查此时系统剩余的可用资源是否还能满足这次请求
      *  试探着分配，更改各数据结构
      *  用安全性算法检查此次分配是否会导致系统进入不安全状态
   *  安全性算法步骤：
      *  检查当前剩余可用资源是否满足某个进程的最大需求，如果可以，就把该进程加入到安全序列，并把该进程持有的资源回收
      *  不断重复上述过程，看最终能否能让所有进程都加入安全序列。
   *  系统处于不安全状态未必死锁，但死锁一定处于不安全状态。系统处于安全状态一定不会死锁。
   
* 3死锁的检测和解除

    * 检测
        * 资源分配图
        * 死锁检测算法：
            * 依次消除与不阻塞进程相连的边，直到无边可消
            * 所谓不阻塞进程就是指其申请的资源数还足够的进程
            * 死锁定理 若资源分配图是不完全简化的，说明发生了死锁
    * 解除
        * 资源剥夺法
        * 撤销进程(终止进程)
        * 进程回退法

* 

    









































  

​	
























































































* 

##### 线程状态切换





























